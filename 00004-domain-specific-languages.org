#+TITLE: Domain Specific Languages / 领域特定语言
#+SETUPFILE: theme.setup
#+INCLUDE: ./nav.org

* 译者序 & 前言
- 这是一本用特定领域语言写就的关于特定领域语言的书
- 澄清概念和发现模式上老马有超能力
- XML 写的比代码还多, 尖括号刺伤了他们的双眼
- DSL: 让一切更连贯, 更容易理解, 便于维护, 减少 bug, 非程序员也能看懂, 便于和领域专家/客户沟通
- 解释与语言无关的通用原则和特性
- Rudy, 老马最熟悉的动态语言
- 模式结构的元素:
  + 名字
  + 意图和摘要
  + 工作原理和使用场景
  + 例子
* TODO 第一部分　叙述
** 第 1 章入门例子
- 什么是 DSL: domain specific language
*** 哥特式建筑安全系统
*** 状态机模型
- Domain driven design 中的 ubiquitous language (speak the common language)
- 分开了公共代码和可变代码
*** 为格兰特小姐的控制器编写程序
- *XML: 控制器的行为的任何修改都无需发布新的 JAR*
- Extensive testing 广泛测试
- 命令式模型: imperative
- DSL: 可能没有控制结果, 没有其他东西, 图灵不完备, 用它不能编写整个应用, 只能用来描述应用的一个小小方面, 其
  简单性意味着它易于编辑和处理.
- 外部 DSL, 内部 DSL
- 内部 DSL 中的一个概念是 fluent interface (连贯性接口), 和 DSL 联系紧密
- 非连贯性接口: command-query API
*** 语言和语义模型
- almost always
- 设计良好的 DSL, 语义模型至关重要
- DSL 只是模型的一个薄薄的 "门面" (facade), (tip: SLFJ 是各种 logging 库的 facade)
*** 用代码生成
- interpretation 解释
- code generation 代码生成, 笨拙: 需要额外的编译步骤; 优势: 解析器和生成代码可以用不同的语言
*** 使用语言工作台
- 语言工作台, 一个专用的 IDE, 可能带有图形界面 (程序员怀疑这种玩具式的工具)
- 类似于语言工作台, 提供文本编辑器. 后 IntelliJ 的能力: 为基于文本的语言提供类似语法指导的编辑, 自动补全及其他类似的功能
- 许多人不把电子表格当做编程环境: 把工具紧密地集成到了编程环境
- 说明性编程 illustrative programming
*** 可视化
- 类似 dot (graphviz) 的界面
** 第 2 章　使用 DSL
*** 定义 DSL                                                           :best:
- domain specific languages 的四个关键因素:
  + *computer programming language* (计算机程序设计语言), 可以执行
  + *language nature (语言性)*, 连贯的表达能力
  + *limited expressiveness (受限的表达)*, 只支持特定领域所需特性的最小集 (MVP: minimum viable product)
  + *domain focus (针对领域)*, 明确性
- 分类:
  + 外部 DSL
  + 内部 DSL
  + 语言工作台
- command-query API 定义了抽象领域的词汇, 内部 DSL 在此基础上添加了语法
- 内部 DSL 给人的感觉是一个整句, 而非无关命令的序列
- 有限的表达性让 DSL 产生了独特性
- 片段 DSL 和独立 DSL
  + 片段 DSL 是和其他语言整合在一起的, 比如 regex
  + sql 可以看成片段, 也可以看成独立 DSL
*** 为何需要 DSL
- 提高开发效率
- 与领域专家的沟通
- 执行环境的改变: 参考 XML 帮助 JAR 包配置不同的运行方式这一点
- 提高开发效率
- 其他计算模型 (比如状态机模型, 网络依赖模型, etc)
*** DSL 的问题
- 语言噪音
- 构建成本 (可维护性)
- 集中营语言 (ghetto language): 小心 DSL 演变成通用语言
- 一叶障目的抽象: 应当视 DSL 为一种 "不断演化, 尚未完结" 的事务
*** 广义的语言处理
*** DSL 的生命周期
- 先描述一个框架: command-query API -> 构建一层 DSL 来简化
- 先定义 DSL: 从场景开始 (最好和领域专家 pair)
- 从最简单的用例开始, 采用测试驱动的方式开发
- 基于模型发展 DSL: 模型生长 (model-seeded), 语言生长 (language-seeded)
*** 设计优良的 DSL 从何而来
- DSL 的总体目标: 对读者要清晰
- trick: 采用日常生活里的通用约定 (一个例子是 JSON 采用了程序员都见过的 [l,i,s,t], {object}, key:value 这几个符号标记法)
** 第 3 章实现 DSL
*** DSL 处理之架构
*** 解析器的工作方式
*** 文法、语法和语义
*** 解析中的数据
*** 宏
*** 测试 DSL
*** 错误处理
*** DSL 迁移
** 第 4 章实现内部 DSL
*** 连贯 API 与命令–查询 API
*** 解析层的需求
*** 使用函数
*** 字面量集合
*** 基于文法选择内部元素
*** 闭包
*** 解析树操作
*** 标注
*** 为字面量提供扩展
*** 消除语法噪音
*** 动态接收
*** 提供类型检查
** 第 5 章实现外部 DSL
*** 语法分析策略
*** 输出生成策略
*** 解析中的概念
*** 混入另一种语言
*** XML DSL
** 第 6 章内部 DSL vs 外部 DSL
*** 学习曲线
*** 创建成本
*** 程序员的熟悉度
*** 与领域专家沟通
*** 与宿主语言混合
*** 强边界
*** 运行时配置
*** 趋于平庸
*** 组合多种 DSL
*** 总结
** 第 7 章其他计算模型概述
*** 7.1 几种计算模型
** 第 8 章代码生成
*** 选择生成什么
*** 如何生成
*** 混合生成代码和手写代码
*** 生成可读的代码
*** 解析之前的代码生成
*** 延伸阅读
** 第 9 章语言工作台
*** 语言工作台之要素
*** 模式定义语言和元模型
*** 源码编辑和投射编辑
*** 说明性编程
*** 工具之旅
*** 语言工作台和 CASE 工具
* 第二部分　通用主题
** TODO 第 10 章各种 DSL
*** Graphviz
*** JMock
*** CSS
*** HQL
*** XAML
*** FIT
*** Make 等
** TODO 第 11 章语义模型
*** 工作原理
*** 使用场景
*** 入门例子（Java）
** 第 12 章符号表
*** 工作原理
*** 使用场景
*** 参考文献
*** 以外部 DSL 实现的依赖网络（Java 和 ANTLR）
*** 在一个内部 DSL 中使用符号键（Ruby）
*** 用枚举作为静态类型符号（Java）
** 第 13 章语境变量
*** 工作原理
*** 使用场景
*** 读取 INI 文件（C#）
** 第 14 章构造型生成器
*** 工作原理
*** 使用场景
*** 构建简单的航班信息（C#）
** 第 15 章宏
*** 工作原理
*** 使用场景
** 第 16 章通知
*** 工作原理
*** 使用场景
*** 一个非常简单的通知（C#）
*** 解析中的通知（Java）
* 第三部分　外部 DSL 主题
** TODO 第 17 章分隔符指导翻译
*** 工作原理
*** 使用场景
*** 常客记分（C#）
*** 使用格兰特小姐的控制器解析非自治语句 (Java)
** TODO 第 18 章语法指导翻译
*** 工作原理
*** 使用场景
*** 参考文献
** TODO 第 19 章 BNF
*** 工作原理
*** 使用场景
** 第 20 章基于正则表达式表的词法分析器
*** 工作原理
*** 使用场景
*** 格兰特小姐控制器的词法处理（Java）
** 第 21 章递归下降法语法解析器
*** 工作原理
*** 使用场景
*** 参考文献
*** 递归下降和格兰特小姐的控制器（Java）
** 第 22 章解析器组合子
*** 工作原理
*** 使用场景
*** 解析器组合子和格兰特小姐的控制器（Java）
** 第 23 章解析器生成器
*** 工作原理
*** 使用场景
23.3Hello World（Java 和 ANTLR）
** 第 24 章树的构建
*** 工作原理
*** 使用场景
*** 使用 ANTLR 的树构建语法（Java 和 ANTLR）
*** 使用代码动作进行树的构建（Java 和 ANTLR）
** 第 25 章嵌入式语法翻译
*** 工作原理
*** 使用场景
*** 格兰特小姐的控制器（Java 和 ANTLR）
** 第 26 章内嵌解释器
*** 工作原理
*** 使用场景
*** 计算器（ANTLR 和 Java）
** 第 27 章外加代码
*** 工作原理
*** 使用场景
*** 嵌入动态代码（ANTLR、Java 和 JavaScript）
** 第 28 章可变分词方式
*** 工作原理
*** 使用场景
** 第 29 章嵌套的运算符表达式
*** 工作原理
*** 使用场景
** 第 30 章以换行符作为分隔符
*** 工作原理
*** 使用场景
** 第 31 章外部 DSL 拾遗
*** 语法缩进
*** 模块化文法
* 第四部分　内部 DSL 主题
** 第 32 章表达式生成器
*** 工作原理
*** 使用场景
*** 具有和没有生成器的连贯日历（Java）
*** 对于日历使用多个生成器（Java）
** 第 33 章函数序列
*** 工作原理
*** 使用场景
*** 简单的计算机配置（Java）
** 第 34 章嵌套函数
*** 工作原理
*** 使用场景
*** 简单计算机配置范例（Java）
*** 用标记处理多个不同的参数（C#）
*** 针对 IDE 支持使用子类型标记（Java）
*** 使用对象初始化器（C#）
*** 周期性事件（C#）
** 第 35 章方法级联
*** 工作原理
*** 使用场景
*** 简单的计算机配置范例（Java）
*** 带有属性的方法级联（C#）
*** 渐进式接口（C#）
** 第 36 章对象范围
*** 工作原理
*** 使用场景
*** 安全代码（C#）
*** 使用实例求值（Ruby）
*** 使用实例初始化器（Java）
** 第 37 章闭包
*** 工作原理
*** 使用场景
** 第 38 章嵌套闭包
*** 工作原理
*** 使用场景
*** 用嵌套闭包来包装函数序列（Ruby）
*** 简单的 C# 示例（C#）
*** 使用方法级联（Ruby）
*** 带显式闭包参数的函数序列（Ruby）
*** 采用实例级求值（Ruby）
** 第 39 章列表的字面构造
*** 工作原理
*** 使用场景
** 第 40 章 Literal Map
*** 工作原理
*** 使用场景
*** 使用 List 和 Map 表达计算机的配置信息（Ruby）
*** 演化为 Greenspun 式（Ruby）
** 第 41 章动态接收
*** 工作原理
*** 使用场景
*** 积分——使用方法名解析（Ruby）
*** 积分——使用方法级联（Ruby）
*** 去掉安全仪表盘控制器中的引用（JRuby）
** TODO 第 42 章标注
*** 工作原理
*** 使用场景
*** 用于运行时处理的特定语法（Java）
*** 使用类方法（Ruby）
*** 动态代码生成（Ruby）
** 第 43 章解析树操作
*** 工作原理
*** 使用场景
*** 由 C# 条件生成 IMAP 查询（C#）
** 第 44 章类符号表
44.1　工作原理
*** 使用场景
*** 在静态类型中实现类符号表（Java）
** 第 45 章文本润色
*** 工作原理
*** 使用场景
*** 使用润色的折扣规则（Ruby）
** 第 46 章为字面量提供扩展
*** 工作原理
*** 使用场景
*** 食谱配料（C#）
* 第五部分　其他计算模型
** 第 47 章适应性模型
*** 工作原理
*** 使用场景
** 第 48 章决策表
*** 工作原理
*** 使用场景
*** 为一个订单计算费用（C#）
** TODO 第 49 章依赖网络
*** 工作原理
*** 使用场景
*** 分析饮料（C#）
** 第 50 章产生式规则系统
*** 工作原理
*** 使用场景
*** 俱乐部会员校验（C#）
*** 适任资格的规则：扩展俱乐部成员（C#）
** TODO 第 51 章状态机
*** 工作原理
*** 使用场景
*** 安全面板控制器（Java）
* 第六部分　代码生成
** 第 52 章基于转换器的代码生成
*** 工作原理
*** 使用场景
*** 安全面板控制器（Java 生成的 C）
** TODO 第 53 章模板化的生成器
*** 工作原理
*** 使用场景
*** 生成带有嵌套条件的安全控制面板状态机（Velocity 和 Java 生成的 C）
** 第 54 章嵌入助手
*** 工作原理
*** 使用场景
*** 安全控制面板的状态（Java 和 ANTLR）
*** 助手类应该生成 HTML 吗（Java 和 Velocity）
** 第 55 章基于模型的代码生成
*** 工作原理
*** 使用场景
*** 安全控制面板的状态机（C）
*** 动态载入状态机（C）
** 第 56 章无视模型的代码生成
*** 工作原理
*** 使用场景
*** 使用嵌套条件的安全面板状态机（C）
** 第 57 章代沟
*** 工作原理
*** 使用场景
*** 根据数据结构生成类（Java 和一些 Ruby）
* 参考文献
